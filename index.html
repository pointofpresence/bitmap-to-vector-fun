<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg path {
  fill: none;
  stroke: red;
}
</style>
<title>Bitmap to Vector Fun</title>
<p>Hello.</p>
<pre id="hi">
*    *
*    
***  * ***
* *  * * *
* *  * ***
</pre>
<script>
function asciiToGrid(text) {
  var lines = text.split('\n');
  var grid = [];
  var char;

  grid.EMPTY = false;
  grid.FILLED = true;
  grid.height = lines.length;
  grid.width = Math.max.apply(Math, lines.map(function(line) {
    return line.length;
  }));

  for (var i = 0; i < grid.height; i++) {
    grid.push([]);
    for (var j = 0; j < grid.width; j++) {
      char = lines[i].charAt(j);
      grid[i].push((!char || char == ' ') ? grid.EMPTY : grid.FILLED);
    }
  }

  grid.getSquare = function(x, y) {
    return grid[y][x];
  };

  return grid;
}

function gridToPaths(grid, squareSize, offset) {
  offset = offset || 0;

  var gridInfo = [];
  var paths = [];
  var i, j;

  var addToPath = function(pathId, x1, y1, x2, y2) {
    var path = paths[pathId];
    var doMove = false;
    var lastCmd;

    if (path.length == 0) {
      doMove = true;
    } else {
      lastCmd = path[path.length - 1];
      if (!(lastCmd.x == x1 && lastCmd.y == y1))
        doMove = true;
    }

    if (doMove) {
      path.push({
        cmd: 'M',
        x: x1,
        y: y1
      });
    }
    path.push({
      cmd: 'L',
      x: x2,
      y: y2
    });
  };

  var visit = function(x, y, pathId) {
    if (gridInfo[y][x].visited) return;
    gridInfo[y][x].visited = true;

    if (pathId === null) {
      pathId = paths.length;
      paths.push([]);
    }

    var top = y * squareSize + offset;
    var left = x * squareSize + offset;
    var bottom = top + squareSize;
    var right = left + squareSize;

    if (getSquare(x, y - 1) === grid.EMPTY) {
      // Add top edge to path
      addToPath(pathId, left, top, right, top);
    } else {
      visit(x, y - 1, pathId);
    }

    if (getSquare(x + 1, y) === grid.EMPTY) {
      // Add right edge to path
      addToPath(pathId, right, top, right, bottom);
    } else {
      visit(x + 1, y, pathId);
    }

    if (getSquare(x, y + 1) === grid.EMPTY) {
      // Add bottom edge to path
      addToPath(pathId, right, bottom, left, bottom);
    } else {
      visit(x, y + 1, pathId);
    }

    if (getSquare(x - 1, y) === grid.EMPTY) {
      // Add left edge to path
      addToPath(pathId, left, bottom, left, top);
    } else {
      visit(x - 1, y, pathId);
    }
  };

  var getSquare = function(x, y) {
    if (x < 0 || x >= grid.width ||
        y < 0 || y >= grid.height)
      return grid.EMPTY;
    return grid.getSquare(x, y);
  };

  for (i = 0; i < grid.height; i++) {
    gridInfo.push([]);
    for (j = 0; j < grid.width; j++) {
      gridInfo[i].push({
        visited: false
      });
    }
  }

  for (i = 0; i < grid.height; i++) {
    for (j = 0; j < grid.width; j++) {
      if (getSquare(j, i) !== grid.EMPTY) {
        visit(j, i, null);
      }
    }
  }

  return paths;
}

function pathsToSVG(paths) {
  var NS = 'http://www.w3.org/2000/svg';
  var svg = document.createElementNS(NS, 'svg');
  var svgWidth = grid.width * SQUARE_SIZE + 1;
  var svgHeight = grid.height * SQUARE_SIZE + 1;

  svg.setAttribute('width', svgWidth);
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewPort', '0 0 ' + svgWidth + ' ' + svgHeight);

  paths.forEach(function(path) {
    var svgPath = document.createElementNS(NS, 'path');
    var d = path.map(function(desc) {
      return desc.cmd + desc.x + ',' + desc.y;
    }).join('');
    svgPath.setAttribute('d', d);
    svg.appendChild(svgPath);
  });

  return svg;
}

var SQUARE_SIZE = 16;

var grid = asciiToGrid(document.getElementById('hi').textContent.trim());

var paths = gridToPaths(grid, SQUARE_SIZE, 0.5);

document.body.appendChild(pathsToSVG(paths));
</script>
