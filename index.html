<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg path {
  fill: red;
  stroke: black;
}
</style>
<title>Bitmap to Vector Fun</title>
<p>Hello.</p>
<pre id="ascii-art">
    *   *     ***
    *         *
*** *** * *** * ***
* * * * * * * *  *
*** * * * *** ****
</pre>
<script src="ascii2grid.js"></script>
<script src="grid2paths.js"></script>
<script>
var SVG_NS = 'http://www.w3.org/2000/svg';

function createSVGElement(width, height) {
  var svg = document.createElementNS(SVG_NS, 'svg');

  svg.setAttribute('width', width);
  svg.setAttribute('height', height);
  svg.setAttribute('viewPort', '0 0 ' + width + ' ' + height);

  return svg;
}

function createStraightSVGPaths(paths) {
  var g = document.createElementNS(SVG_NS, 'g');

  paths.paths.forEach(function(subpaths) {
    var svgPath = document.createElementNS(SVG_NS, 'path');
    var d = subpaths.map(function(subpath) {
      var moveTo = 'M' + subpath[0].x + ',' + subpath[0].y + ' ';

      return moveTo + subpath.slice(1).map(function lineTo(point, i) {
        return 'L' + point.x + ',' + point.y;
      }).join(' ') + 'z';
    }).join(' ');
    svgPath.setAttribute('d', d);
    g.appendChild(svgPath);
  });

  return g;
}

function createCurvySVGPaths(paths, curveAmount) {
  var g = document.createElementNS(SVG_NS, 'g');

  paths.paths.forEach(function(subpaths) {
    var svgPath = document.createElementNS(SVG_NS, 'path');
    var d = subpaths.map(function(subpath) {
      var moveTo = 'M' + subpath[0].x + ',' + subpath[0].y + ' ';

      return moveTo + subpath.slice(1).map(function lineTo(point, i) {
        var prevPoint = subpath[i];
        var nextPoint = subpath[(i + 2) % subpath.length];

        cx = point.x;
        cy = point.y;

        if (prevPoint.x > point.x) {
          cx += curveAmount;
        } else if (prevPoint.x < point.x) {
          cx -= curveAmount;
        }

        if (nextPoint.y > point.y) {
          cy -= curveAmount;
        } else if (nextPoint.y < point.y) {
          cy += curveAmount;
        }

        return 'Q ' + cx + ',' + cy + ' ' +
               point.x + ',' + point.y;
      }).join(' ') + 'z';
    }).join(' ');
    svgPath.setAttribute('d', d);
    g.appendChild(svgPath);
  });

  return g;
}

function createJitterySVGPaths(paths, jitterAmount) {
  var g = document.createElementNS(SVG_NS, 'g');

  paths.paths.forEach(function(subpaths) {
    var svgPath = document.createElementNS(SVG_NS, 'path');
    var d = subpaths.map(function(subpath) {
      var moveTo = 'M' + subpath[0].x + ',' + subpath[0].y + ' ';

      return moveTo + subpath.slice(1).map(function lineTo(point, i) {
        var cx = point.x + Math.random() * jitterAmount;
        var cy = point.y + Math.random() * jitterAmount;

        var x = point.x + Math.random() * jitterAmount;
        var y = point.y + Math.random() * jitterAmount;

        return 'Q ' + cx + ',' + cy + ' ' + x + ',' + y;
      }).join(' ') + 'z';
    }).join(' ');
    svgPath.setAttribute('d', d);
    g.appendChild(svgPath);
  });

  return g;
}

function createSVGCirclesAtVertices(paths, radius) {
  var g = document.createElementNS(SVG_NS, 'g');

  paths.paths.forEach(function(subpaths) {
    subpaths.forEach(function(subpath) {
      subpath.forEach(function(point) {
        var circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', radius);
        g.appendChild(circle);
      });
    });
  });

  return g;
}

var SQUARE_SIZE = 16;

var grid = asciiToGrid(document.getElementById('ascii-art').textContent);

var paths = gridToPaths(grid, SQUARE_SIZE, 5);

var svg = createSVGElement(paths.width, paths.height);

svg.appendChild(createStraightSVGPaths(paths));
//svg.appendChild(createCurvySVGPaths(paths, 4));

//svg.appendChild(createJitterySVGPaths(paths, 4));
svg.appendChild(createSVGCirclesAtVertices(paths, 2));

document.body.appendChild(svg);
</script>
